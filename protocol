<i>This protocol is implemented in Firefox, and is the basis of Firefox's built-in JavaScript debugger. You can use the [https://github.com/jimblandy/DebuggerDocs GitHub DebuggerDocs repo] to draft and discuss revisions.)</i>

The Mozilla debugging protocol allows a debugger to connect to a browser, discover what sorts of things are present to debug or inspect, select JavaScript threads to watch, and observe and modify their execution. The protocol provides a unified view of JavaScript, DOM nodes, CSS rules, and the other technologies used in client-side web applications. The protocol ought to be sufficiently general to be extended for use with other sorts of clients (profilers, say) and servers (mail readers; random XULrunner applications).

All communication between debugger (client) and browser (server) is in the form of JSON objects. This makes the protocol directly readable by humans, capable of graceful evolution, and easy to implement using stock libraries. In particular, it should be easy to create mock implementations for testing and experimentation.

The protocol operates at the JavaScript level, not at the C++ or machine level, and assumes that the JavaScript implementation itself is healthy and responsive. The JavaScript program being executed may well have gone wrong, but the JavaScript implementation's internal state must not be corrupt. Bugs in the implementation may cause the debugger to fail; bugs in the interpreted program must not.

= General Conventions =

== Actors ==

An <b>actor</b> is something on the server that can exchange JSON packets with the client. Every packet from the client specifies the actor to which it is directed, and every packet from the server indicates which actor sent it.

Each server has a root actor, with which the client first interacts. The root actor can explain what sort of thing the server represents (browser; mail reader; etc.), and enumerate things available to debug: tabs, chrome, and so on. Each of these, in turn, is represented by an actor to which requests can be addressed. Both artifacts of the program being debugged, like JavaScript objects and stack frames, and artifacts of the debugging machinery, like breakpoints and watchpoints, are actors with whom packets can be exchanged.

For example, a debugger might connect to a browser, ask the root actor to list the browser's tabs, and present this list to the developer. If the developer chooses some tabs to debug, then the debugger can send <tt>attach</tt> requests to the actors representing those tabs, to begin debugging.

Actor names are JSON strings. The name of the root actor is <code>"root"</code>.

To allow the server to reuse actor names and the resources they require, actors have limited lifetimes. All actors in a server form a tree, whose root is the root actor. Closing communications with an actor automatically closes communications with its descendants. For example, the actors representing a thread's stack frames are children of the actor representing the thread itself, so that when a debugger detaches from a thread, which closes the thread's actor, the frames' actors are automatically closed. This arrangement allows the protocol to mention actors liberally, without making the client responsible for explicitly closing every actor that has ever been mentioned.

When we say that some actor <i>A</i> is a <b>child</b> of some actor <i>B</i>, we mean that <i>A</i> is a direct child of <i>B</i>, not a grandchild, great-grandchild, or the like. Similarly, <b>parent</b> means "direct parent". We use the terms <b>ancestor</b> and <b>descendent</b> to refer to those looser relationships.

The root actor has no parent, and lives as long as the underlying connection to the client does; when that connection is closed, all actors are closed.

Note that the actor hierarchy does not, in general, correspond to any particular hierarchy appearing in the debuggee. For example, although web workers are arranged in a hierarchy, the actors representing web worker threads are all children of the root actor: one might want to detach from a parent worker while continuing to debug one of its children, so it doesn't make sense to close communications with a child worker simply because one has closed communications with its parent.

<i>(We are stealing the "actor" terminology from Mozilla's [[IPDL]], to mean, roughly, "things participating in the protocol". However, IPDL does much more with the idea than we do: it treats both client and server as collections of actors, and uses that detail to statically verify properties of the protocol. In contrast, the debugging protocol simply wants a consistent way to indicate the entities to which packets are directed.)</i>

== Packets ==

The protocol is carried by a reliable, bi-directional byte stream; data sent in both directions consists of JSON objects, called packets. A packet is a top-level JSON object, not contained inside any other value.

Every packet sent from the client has the form:

  { "to":<i>actor</i>, "type":<i>type</i>, ... }

where <i>actor</i> is the name of the actor to whom the packet is directed and <i>type</i> is a string specifying what sort of packet it is. Additional properties may be present, depending on <i>type</i>.

Every packet sent from the server has the form:

  { "from":<i>actor</i>, ... }

where <i>actor</i> is the name of the actor that sent it. The packet may have additional properties, depending on the situation.

If a packet is directed to an actor that no longer exists, the server sends a packet to the client of the following form:

  { "from":<i>actor</i>, "error":"noSuchActor" }

where <i>actor</i> is the name of the non-existent actor. (It is strange to receive messages from actors that do not exist, but the client evidently believes that actor exists, and this reply allows the client to pair up the error report with the source of the problem.)

Clients should silently ignore packet properties they do not recognize. We expect that, as the protocol evolves, we will specify new properties that can appear in existing packets, and experimental implementations will do the same.

== Common Patterns of Actor Communication ==

Each type of actor specifies which packets it can receive, which it might send, and when it can do each. Although in principle these interaction rules could be complex, in practice most actors follow one of two simple patterns:

<ul>
<li><b>Request/Reply</b>: Each packet sent to the actor ("request") elicits a single packet in response ("reply").
<li><b>Request/Reply/Notify</b>: Like Request/Reply, but the actor may send packets that are not in response to any specific request ("notification"), perhaps announcing events that occur spontaneously in the debuggee.
</ul>

These patterns are described in more detail below.

Some actors require more complicated rules. For example, the set of packets accepted by a [[#Interacting_with_Thread-Like_Actors|Thread-like actor]] depends on which one of four states it occupies. The actor may spontaneously transition from one state to another, and not all state transitions produce notification packets. Actors like this require careful specification.

=== The Request/Reply Pattern ===

In this specification, if we call a packet a <b>request</b>, then it is a packet sent by the client, which always elicits a single packet from the actor in return, the <b>reply</b>. These terms indicate a simple pattern of communication: the actor processes packets in the order they are received, and the client can trust that the <i>i</i>'th reply corresponds to the <i>i</i>'th request.

An [[#Error_Packets|error reply]] packet from a request/reply actor constitutes a reply.

Note that it is correct for a client to send several requests to a request/reply actor without waiting for a reply to each request before sending the next; requests can be pipelined. However, as the pending requests consume memory, the client should ensure that only a bounded number of requests are outstanding at any one time.

=== The Request/Reply/Notify Pattern ===

Some actors follow the request/reply pattern, but may also send the client <b>notification</b> packets, not in reply to any particular request. For example, if the client sends the root actor a [[#Listing_Browser_Tabs|<code>"listTabs"</code>]] request, then the root actor sends a reply. However, since the client has now expressed an interest in the list of open tabs, the root actor may subsequently send the client a <code>"tabListChanged"</code> notification packet, indicating that the client should re-fetch the list of tabs if it is interested in the latest state.

There should be a small upper bound on the number of notification packets any actor may send between packets received from the client, to ensure that the actor does not flood the client. In the example above, the root actor sends at most one <code>"tabListChanged"</code> notification after each <code>"listTabs"</code> request.

=== Error Packets ===

Any actor can reply to a packet it is unable to process with an <b>error reply</b> of the form:

  { "from":<i>actor</i>, "error":<i>name</i>, "message":<i>message</i> }

where <i>name</i> is a JSON string naming what went wrong, and <i>message</i> is an English error message. Error <i>name</i>s are specified by the protocol; the client can use the name to identify which error condition arose. The <i>message</i> may vary from implementation to implementation, and should only be displayed to the user as a last resort, as the server lacks enough information about the user interface context to provide appropriate messages.

If an actor receives a packet whose type it does not recognize, it sends an error reply of the form:

  { "from":<i>actor</i>, "error":"unrecognizedPacketType", "message":<i>message</i> }

where <i>message</i> provides details to help debugger developers understand what went wrong: what kind of actor <i>actor</i> is; the packet received; and so on.

If an actor recieves a packet which is missing needed parameters (say, a <tt>"releaseMany"</tt> packet with no <tt>"actors"</tt> parameter), it sends an error reply of the form:

  { "from":<i>actor</i>, "error":"missingParameter", "message":<i>message</i> }

where <i>message</i> provides details to help debugger developers fix the problem.

If an actor recieves a packet with a parameter whose value is inappropriate for the operation, it sends an error reply of the form:

  { "from":<i>actor</i>, "error":"badParameterType", "message":<i>message</i> }

where <i>message</i> provides details to help debugger developers fix the problem. (Some packets' descriptions specify more specific errors for particular circumstances.)

== Grips ==

A grip is a JSON value that refers to a specific JavaScript value in the debuggee. Grips appear anywhere an arbitrary value from the debuggee needs to be conveyed to the client: stack frames, object property lists, lexical environments, <tt>paused</tt> packets, and so on.

For mutable values like objects and arrays, grips do not merely convey the value's current state to the client. They also act as references to the original value, by including an actor to which the client can send messages to modify the value in the debuggee.

A grip has one of the following forms:

  <i>value</i>

where <i>value</i> is a string, a number, or a boolean value. For these types of values, the grip is simply the JSON form of the value.

  { "type":"null" }

This represents the JavaScript <tt>null</tt> value. (The protocol does not represent JavaScript <tt>null</tt> simply by the JSON <tt>null</tt>, for the convenience of clients implemented in JavaScript: this representation allows such clients to use <tt>typeof(<i>grip</i>) == "object"</tt> to decide whether the grip is simple or not.)

  { "type":"undefined" }

This represents the JavaScript <tt>undefined</tt> value. (<tt>undefined</tt> has no direct representation in JSON.)

  { "type":"Infinity" }

This represents the JavaScript <tt>Infinity</tt> value. (<tt>Infinity</tt> has no direct representation in JSON.)

  { "type":"-Infinity" }

This represents the JavaScript <tt>-Infinity</tt> value. (<tt>-Infinity</tt> has no direct representation in JSON.)

  { "type":"NaN" }

This represents the JavaScript <tt>NaN</tt> value. (<tt>NaN</tt> has no direct representation in JSON.)

  { "type":"-0" }

This represents the JavaScript <tt>-0</tt> value. (<tt>-0</tt> stringifies to JSON as 0.)

  { "type":"object", "class":<i>className</i>, "actor":<i>actor</i> }

This represents a JavaScript object whose class is <i>className</i>. (Arrays and functions are treated as objects for the sake of forming grips.) <i>Actor</i> can be consulted for the object's contents, as explained below.

If the class is "Function", the grip may have additional properties:

  { "type":"object", "class":"Function", "actor":<i>actor</i>,
    "name":<i>name</i>, "displayName":<i>displayName</i>,
    "userDisplayName":<i>userDisplayName</i>,
    "url":<i>url</i>, "line":<i>line</i>, "column":<i>column</i> }

These additional properties are:
<dl>
<dt><i>name</i>
<dd>The function's name (as given in the source code, following the <code>function</code> keyword), as a string. If the function is anonymous, the <code>name</code> property is omitted.
<dt><i>displayName</i>
<dd>A name the system has inferred for the function (say, <code>"Foo.method"</code>). If the function has a given name (appearing in the grip as the <code>"name"</code> property), or if the system was unable to infer a suitable name for it, the <code>displayName</code> property is omitted.
<dt><i>userDisplayName</i>
<dd>If the function object has a <code>"displayName"</code> value property whose value is a string, this is that property's value. (Many JavaScript development tools consult such properties, to give developers a way to provide their own meaningful names for functions.)
<dt><i>url</i>
<dd>The URL of the function's source location (see [[#Source_Locations|Source Locations]]);
<dt><i>line</i>
<dd>The line number of the function's source location (see [[#Source_Locations|Source Locations]]);
<dt><i>column</i>
<dd>The column number of the function's source location (see [[#Source_Locations|Source Locations]]);
</dl>

  { "type":"longString", "initial":<i>initial</i>, "length":<i>length</i>, "actor":<i>actor</i> }

This represents a very long string, where "very long" is defined at the server's discretion. <i>Initial</i> is some initial portion of the string, <i>length</i> is the string's full length, and <i>actor</i> can be consulted for the rest of the string, as explained below.

For example, the following table shows some JavaScript expressions and the grips that would represent them in the protocol:

{| frame="box" rules="all" cellpadding="8"
! JavaScript Expression
! Grip
|-
| 42
| 42
|-
| true
| true
|-
| "nasu"
| "nasu"
|-
| (void 0)
| { "type":"undefined" }
|-
| ({x:1})
| { "type":"object", "class":"Object", "actor":"24" }
|-
| "Arms and the man I sing, who, <i>[much, much more text]</i>"
| { "type":"longString", "initial":"Arms and the man I sing", "length":606647, "actor":"25" }
|}

Garbage collection will never free objects visible to the client via the protocol. Thus, actors representing JavaScript objects are effectively garbage collection roots.

=== Objects ===

While a thread is paused, the client can send requests to the actors appearing in object grips to examine the objects they represent in more detail.

==== Property Descriptors ====

Protocol requests that describe objects' properties to the client often use <b>descriptors</b>, JSON values modeled after ECMAScript 5's property descriptors, to describe individual properties.

A descriptor has the form:

  { "enumerable":<i>enumerable</i>, "configurable":<i>configurable</i>, ... }

where <i>enumerable</i> and <i>configurable</i> are boolean values indicating whether the property is enumerable and configurable, and additional properties are present depending on what sort of property it is.

A descriptor for a data property has the form:

  { "enumerable":<i>enumerable</i>, "configurable":<i>configurable</i>,
    "value":<i>value</i>, "writeable":<i>writeable</i> }

where <i>value</i> is a grip on the property's value, and <i>writeable</i> is a boolean value indicating whether the property is writeable.

A descriptor for an accessor property has the form:

  { "enumerable":<i>enumerable</i>, "configurable":<i>configurable</i>,
    "get":<i>getter</i>, "set":<i>setter</i> }

where <i>getter</i> and <i>setter</i> are grips on the property's getter and setter functions. These may be <tt>{&nbsp;"type":"undefined"&nbsp;}</tt> if the property lacks the given accessor function.

A <b>safe getter value descriptor</b> provides a value that an inherited accessor returned when applied to an instance. (See [[#Finding_An_Object's_Prototype_And_Properties|Finding An Object's Prototype And Properties]] for an explanation of why and when such descriptors are used.) Such a descriptor has the form:

  { "getterValue": <i>value</i>, "getterPrototypeLevel": <i>level</i>,
    "enumerable":<i>enumerable</i>, "writable":<i>writable</i> }

where <i>value</i> is a grip on the value the getter returned, <i>level</i> is the number of steps up the object's prototype chain one must take to find the object on which the getter appears as an own property. If the getter appears directly on the object, <i>level</i> is zero. The <i>writable</i> property is true if the inherited accessor has a setter, and false otherwise.

For example, if the JavaScript program being debugged evaluates the expression:

  ({x:10, y:"kaiju", get a() { return 42; }})

then a grip on this value would have the form:

  { "type":"object", "class":"Object", "actor":<i>actor</i> }

and sending a [[#Finding_An_Object's_Prototype_And_Properties|"prototypeAndProperties"]] request to <i>actor</i> would produce the following reply:

  { "from":<i>actor</i>, "prototype":{ "type":"object", "class":"Object", "actor":<i>objprotoActor</i> },
    "ownProperties":{ "x":{ "enumerable":true, "configurable":true, "writeable":true, "value":10 },
                      "y":{ "enumerable":true, "configurable":true, "writeable":true, "value":"kaiju" },
                      "a":{ "enumerable":true, "configurable":true,
                            "get":{ "type":"object", "class":"Function", "actor":<i>getterActor</i> },
                            "set":{ "type":"undefined" }
                          }
                     }
  }

Sending a [[#Finding_An_Object's_Prototype_And_Properties|"prototypeAndProperties"]] request to an object actor referring to a DOM mouse event might produce the following reply:

  { "from":<i>mouseEventActor</i>, "prototype":{ "type":"object", "class":"MouseEvent", "actor":<i>mouseEventProtoActor</i> },
    "ownProperties":{ }
    "safeGetterValues":{ "screenX": { "getterValue": 1000, "getterPrototypeLevel": 1,
                                      "enumerable": true, "writable": false },
                         "screenY": { "getterValue": 1000, "getterPrototypeLevel": 1,
                                      "enumerable": true, "writable": false },
                         "clientX": { "getterValue": 800,  "getterPrototypeLevel": 1,
                                      "enumerable": true, "writable": false },
                         "clientY": { "getterValue": 800,  "getterPrototypeLevel": 1,
                                      "enumerable": true, "writable": false },
                         <i>...</i>
                       }
  }

==== Finding An Object's Prototype And Properties ====

To examine an object's prototype and properties, a client can send the object's grip's actor a request of the form:

  { "to":<i>gripActor</i>, "type":"prototypeAndProperties" }

to which the grip actor replies:

  { "from":<i>gripActor</i>, "prototype":<i>prototype</i>, "ownProperties":<i>ownProperties</i> }

where <i>prototype</i> is a grip on the object's prototype (possibly <tt>{&nbsp;"type":"null"&nbsp;}</tt>), and <i>ownProperties</i> has the form:

  { <i>name</i>:<i>descriptor</i>, ... }

with a <i>name</i>:<i>descriptor</i> pair for each of the object's own properties.

The web makes extensive use of inherited accessor properties; for example, the <code>clientX</code> and <code>clientY</code> properties of a mouse click event are actually accessor properties which the event object inherits from its prototype chain. It can be very valuable to display such properties' values directly on the object (taking care to distinguish them from true "own" properties), if the server can determine that the getters can be called without side effects.

To this end, when possible, the server may provide safe getter value descriptors for an object, as described in [[#Property_Descriptors|Property Descriptors]] above, reporting the values that getter functions found on the object's prototype chain return when applied to that object. If the server chooses to provide any, the reply includes a <code>"safeGetterValues"</code> property of the form:

  { <i>name</i>:<i>descriptor</i>, ... }

with a <i>name</i>:<i>descriptor</i> pair for each safe getter the object inherits from its prototype chain, or that appears directly on the object. Each <i>descriptor</i> here is a safe getter value descriptor.

<i>TODO: What about objects with many properties?</i>

==== Finding an Object's Prototype ====

To find an object's prototype, a client can send the object's grip's actor a request of the form:

  { "to":<i>gripActor</i>, "type":"prototype" }

to which the grip actor replies:

  { "from":<i>gripActor</i>, "prototype":<i>prototype</i> }

where <i>prototype</i> is a grip on the object's prototype (possibly <tt>{ "type":"null" }</tt>).

==== Listing an Object's Own Properties' Names ====

To list an object's own properties' names, a client can send the object's grip's actor a request of the form:

  { "to":<i>gripActor</i>, "type":"ownPropertyNames" }

to which the grip actor replies:

  { "from":<i>gripActor</i>, "ownPropertyNames":[ <i>name</i>, ... ] }

where each <i>name</i> is a string naming an own property of the object.

==== Finding Descriptors For Single Properties ====

To obtain a descriptor for a particular property of an object, a client can send the object's grip's actor a request of the form:

  { "to":<i>gripActor</i>, "type":"property", "name":<i>name</i> }

to which the grip actor replies:

  { "from":<i>gripActor</i>, "descriptor":<i>descriptor</i> }

where <i>descriptor</i> is a descriptor for the own property of the object named <i>name</i>, or <tt>null</tt> if the object has no such own property.

A property descriptor has the form:

  { "configurable":<i>configurable</i>, "enumerable":<i>enumerable</i>, ... }

where <i>configurable</i> and <i>enumerable</i> are boolean values. <i>Configurable</i> is true if the property can be deleted or have its attributes changed. <i>Enumerable</i> is true if the property will be enumerated by a <code>for-in</code> enumeration.

Descriptors for value properties have the form:

  { "configurable":<i>configurable</i>, "enumerable":<i>enumerable</i>,
    "writable":<i>writable</i>, "value":<i>value</i> }

where <i>writable</i> is <code>true</code> if the property's value can be written to; <i>value</i> is a grip on the property's value; and <i>configurable</i> and <i>enumerable</i> are as described above.

Descriptors for accessor properties have the form:

  { "configurable":<i>configurable</i>, "enumerable":<i>enumerable</i>,
    "get":<i>get</i>, "set":<i>set</i> }

where <i>get</i> and <i>set</i> are grips on the property's getter and setter functions; either or both are omitted if the property lacks the given accessor function. <i>Configurable</i> and <i>enumerable</i> are as described above.

<i>TODO: assign to value property</i>

<i>TODO: special stuff for arrays</i>

<i>TODO: special stuff for functions</i>

<i>TODO: find function's source position</i>

<i>TODO: get function's named arguments, in order</i>

<i>TODO: descriptors for Harmony proxies</i>

==== Functions ====

If an object's class as given in the grip is <code>"Function"</code>, then the grip's actor responds to the messages given here.

  { "to":<i>functionGripActor</i>, "type":"parameterNames" }

This requests the names of the parameters of the function represented by <i>functionGripActor</i>. The reply has the form:

  { "from":<i>functionGripActor</i>, "parameterNames":[ <i>parameter</i>, ... ] }

where each <i>parameter</i> is the name of a formal parameter to the function as a string. If the function takes destructuring arguments, then <i>parameter</i> is a structure of JSON array and object forms matching the form of the destructuring arguments.

  { "to":<i>functionGripActor</i>, "type":"scope" }

Return the lexical environment over which the function has closed. The reply has the form:

  { "from":<i>functionGripActor</i>, "scope":<i>environment</i> }

where <i>environment</i> is a [[#Lexical_Environments|lexical environment]]. Note that the server only returns environments of functions in a context being debugged; if the function's global scope is not the browsing context to which we are attached, the function grip actor sends an error reply of the form:

  { "from":<i>functionGripActor</i>, "error":"notDebuggee", "message":<i>message</i> }

where <i>message</i> is text explaining the problem.

  { "to":<i>functionGripActor</i>, "type":"decompile", "pretty":<i>pretty</i> }

Return JavaScript source code for a function equivalent to the one represented by <i>functionGripActor</i>. If the optional <code>pretty</code> parameter is present and <i>pretty</i> is <code>true</code>, then produce indented source code with line breaks. The reply has the form:

  { "from":<i>functionGripActor</i>, "decompiledCode":<i>code</i> }

where <i>code</i> is a string.

If <i>functionGripActor</i>'s referent is not a function, or is a function proxy, the actor responds to these requests with an error reply of the form:

  { "from":<i>functionGripActor</i>, "error":"objectNotFunction", message:<i>message</i> }

where <i>message</i> is a string containing any additional information that would be helpful to debugger developers.

=== Long Strings ===

The client can find the full contents of a long string by sending a request to the long string grip actor of the form:

  { "to":<i>gripActor</i>, "type":"substring", "start":<i>start</i>, "end":<i>end</i> }

where <i>start</i> and <i>end</i> are integers. This requests the substring starting at the <i>start</i>'th character, and ending before the <i>end</i>'th character. The actor replies as follows:

  { "from":<i>gripActor</i>, "substring":<i>string</i> }

where <i>string</i> is the requested portion of the string the actor represents. Values for <i>start</i> less than zero are treated as zero; values greater than the length of the string are treated as the length of the string. Values for <i>end</i> are treated similarly. If <i>end</i> is less than <i>start</i>, the two values are swapped. (This is meant to be the same behavior as JavaScript's <code>String.prototype.substring</code>.)

As with any other actor, the client may only send messages to a long string grip actor while it is alive: for [[#Grip_Lifetimes|pause-lifetime grips]], until the debuggee is resumed; or for [[#Grip_Lifetimes|thread-lifetime grips]], until the thread is detached from or exits. However, unlike object grip actors, the client may communicate with a long string grip actor at any time the actor is alive, regardless of whether the debuggee is paused. (Since strings are immutable values in JavaScript, the responses from a long string grip actor cannot depend on the actions of the debuggee.)

=== Grip Lifetimes ===

Most grips are <b>pause-lifetime</b> grips: they last only while the JavaScript thread is paused, and become invalid as soon as the debugger allows the thread to resume execution. (The actors in pause-lifetime grips are children of an actor that is closed when the thread resumes, or is detached from.) This arrangement allows the protocol to use grips freely in responses without requiring the client to remember and close them all.

However, in some cases the client may wish to retain a reference to an object or long string while the debuggee runs. For example, a panel displaying objects selected by the user must update its view of the objects each time the debuggee pauses. To carry this out, the client can promote a pause-lifetime grip to a <b>thread-lifetime</b> grip, which lasts until the thread is detached from or exits. Actors in thread-lifetime grips are children of the thread actor. When the client no longer needs a thread-lifetime grip, it can explicitly release it.

Both pause-lifetime and thread-lifetime grips are garbage collection roots.

To promote a pause-lifetime grip to a thread-lifetime grip, the client sends a packet of the form:

  { "to":<i>gripActor</i>, "type":"threadGrip" }

where <i>gripActor</i> is the actor from the existing pause-lifetime grip. The grip actor will reply:

  { "from":<i>gripActor</i>, "threadGrip":<i>threadGrip</i> }

where <i>threadGrip</i> is a new grip on the same object, but whose actor is parented by the thread actor, not the pause actor.

The client can release a thread-lifetime grip by sending the grip actor a request of the form:

  { "to":<i>gripActor</i>, "type":"release" }

The grip actor will reply, simply:

  { "from":<i>gripActor</i> }

This closes the grip actor. The <tt>"release"</tt> packet may only be sent to thread-lifetime grip actors; if a pause-lifetime grip actor receives a <tt>"release"</tt> packet, it sends an error reply of the form:

  { "from":<i>gripActor</i>, "error":"notReleasable", "message":<i>message</i> }

where <i>message</i> includes whatever further information would be useful to the debugger developers.

The client can release many thread-lifetime grips in a single operation by sending the thread actor a request of the form:

  { "to":<i>thread</i>, "type":"releaseMany", "actors":[ <i>gripActor</i>, ... ] }

where each <i>gripActor</i> is the name of a child of <i>thread</i> that should be freed. The thread actor will reply, simply:

  { "from":<i>thread</i> }

Regardless of the lifetime of a grip, the client may only send messages to object grip actors while the thread to which they belong is paused; the client's interaction with mutable values cannot take place concurrently with the thread.

== Completion Values ==

Some packets describe the way a stack frame's execution completed using a <b>completion value</b>, which takes one of the following forms:

  { "return":<i>grip</i> }

This indicates that the frame completed normally, returning the value given by <i>grip</i>.

  { "throw":<i>grip</i> }

This indicates that the frame threw an exception; <i>grip</i> is the exception value thrown.

  { "terminated":true }

This indicates that the frame's execution was terminated, as by a "slow script" dialog box or running out of memory.

== Source Locations ==

Many packets refer to particular locations in source code: breakpoint requests specify where the breakpoint should be set; stack frames show the current point of execution; and so on.

Descriptions of source code locations (written as <i>location</i> in packet descriptions) can take one of the following forms:

  { "url":<i>url</i>, "line":<i>line</i>, "column":<i>column</i> }

This refers to line <i>line</i>, column <i>column</i> of the source code loaded from <i>url</i>. Line and column numbers start with 1. If <i>column</i> or <i>line</i> are omitted, they default to 1.

  { "eval":<i>location</i>, "id":<i>id</i>, "line":<i>line</i>, "column":<i>column</i> }

This refers to line <i>line</i>, column <i>column</i> of the source code passed to the call to eval at <i>location</i>. To distinguish the different texts passed to eval, each is assigned a unique integer, <i>id</i>.

  { "function":<i>location</i>, "id":<i>id</i>, "line":<i>line</i>, "column":<i>column</i> }

This refers to line <i>line</i>, column <i>column</i> of the source code passed to the call to the <tt>Function</tt> constructor at <i>location</i>. To distinguish the different texts passed to the <tt>Function</tt> constructor, each is assigned a unique integer, <i>id</i>.

As indicated, locations can be nested. A location like this one:

  { "eval":{ "eval":{ "url":"file:///home/example/sample.js", "line":20 }
             "id":300, "line":30 }
    "id":400, "line":40 }

refers to line 40 of the code passed to the call to eval occurring on line 30 of the code passed to the call to eval on line 20 of <tt>file:///home/example/sample.js</tt>.

= The Root Actor =

When the connection to the server is opened, the root actor opens the conversation with the following packet:

  { "from":"root", "applicationType":<i>appType</i>, "traits":<i>traits</i>, ...}

The root actor's name is always <code>"root"</code>. <i>appType</i> is a string indicating what sort of program the server represents. There may be more properties present, depending on <i>appType</i>.

<i>traits</i> is an object describing protocol variants this server supports that are not convenient for the client to detect otherwise. The property names present indicate what traits the server has; the properties' values depend on their names. If <i>traits</i> would have no properties, the <code>"traits"</code> property of the packet may be omitted altogether. This version of the protocol defines no traits, so if the <code>"traits"</code> property is present at all, its value must be an object with no properties, <tt>{}</tt>.

For web browsers, the introductory packet should have the following form:

  { "from":"root", "applicationType":"browser", "traits":<i>traits</i> }

== Listing Browser Tabs ==

To get a list of the tabs currently present in a browser, a client sends the root actor a request of the form:

  { "to":"root", "type":"listTabs" }

The root actor replies:

  { "from":"root", "tabs":[<i>tab</i>, ...], "selected":<i>selected</i> }

where each <i>tab</i> describes a single open tab, and <i>selected</i> is the index in the array of tabs of the currently selected tab. This form may have other properties describing other global actors; for one example, see [[#Chrome_Debugging|Chrome Debugging]].

Each <i>tab</i> has the form:

  { "actor":<i>tabActor</i>, "title":<i>title</i>, "url":<i>URL</i> }

where <i>tabActor</i> is the name of an actor representing the tab, and <i>title</i> and <i>URL</i> are the title and URL of the web page currently visible in that tab. This form may have other properties describing other tab-specific actors.

To attach to a <i>tabActor</i>, a client sends a message of the form:

  { "to":<i>tabActor</i>, "type":"attach" }

The tab actor replies:

  { "from":<i>tabActor</i>, "type":"tabAttached", "threadActor":<i>tabThreadActor</i>, "cacheEnabled":<i>true</i> ,"javascriptEnabled":<i>true</i> }

where <i>tabThreadActor</i> is the name of a thread-like actor representing the tab's current content. If the user navigates the tab, <i>tabThreadActor</i> switches to the new content; we do not create a separate thread-like actor each page the tab visits. <i>cacheEnabled</i> and <i>javascriptEnabled</i> indicate whether the browser cache and content JavaScript are allowed for the tab.

If the user closes the tab before the client attaches to it, <i>tabActor</i> replies:

  { "from":<i>tabActor</i>, "type":"exited" }

When the client is no longer interested in interacting with the tab, the client can request:

  { "to":<i>tabActor</i>, "type":"detach" }

The <i>tabActor</i> replies:

  { "from":<i>tabActor</i>, "type":"detached" }

If the client was not already attached to <i>tabActor</i>, <i>tabActor</i> sends an error reply of the form:

  { "from":<i>tabActor</i>, "error":"wrongState" }

While the client is attached, <i>tabActor</i> sends notifications to the client whenever the user navigates the tab to a new page. When navigation begins, <i>tabActor</i> sends a packet of the form:

  { "from":<i>tabActor</i>, "type":"tabNavigated", "state":"start",
    "url":<i>newURL</i> }

This indicates that the tab has begun navigating to <i>newURL</i>; JavaScript execution in the tab's prior page is suspended. When navigation is complete, <i>tabActor</i> sends a packet of the form:

  { "from":<i>tabActor</i>, "type":"tabNavigated", "state":"stop",
     "url":<i>newURL</i>, "title":<i>newTitle</i> }

where <i>newURL</i> and <i>newTitle</i> are the URL and title of the page the tab is now showing. The <i>tabThreadActor</i> given in the response to the original <code>"attach"</code> packet is now debugging the new page's code.

If the user closes a tab to which the client is attached, its <i>tabActor</i> sends a notification packet of the form:

  { "from":<i>tabActor</i>, "type":"tabDetached" }

The client is now detached from the tab.

== Chrome Debugging ==

If the server supports debugging chrome code, the root actor's reply to a <code>"listTabs"</code> request includes a property named <code>"chromeDebugger"</code>, whose value is the name of a thread-like actor to which the client can attach to debug chrome code.

= Interacting with Thread-Like Actors =

Actors representing independent threads of JavaScript execution, like browsing contexts and web workers, are collectively known as "threads". Interactions with actors representing threads follow a more complicated communication pattern.

A thread is always in one of the following states:

* <b>Detached</b>: the thread is running freely, and not presently interacting with the debugger. Detached threads run, encounter errors, and exit without exchanging any sort of messages with the debugger. A debugger can attach to a thread, putting it in the <b>Paused</b> state. Or, a detached thread may exit on its own, entering the <b>Exited</b> state.

* <b>Running</b>: the thread is running under the debugger's observation, executing JavaScript code or possibly blocked waiting for input. It will report exceptions, breakpoint hits, watchpoint hits, and other interesting events to the client, and enter the <b>Paused</b> state. The debugger can also interrupt a running thread; this elicits a response and puts the thread in the <b>Paused</b> state. A running thread may also exit, entering the <b>Exited</b> state.

* <b>Paused</b>: the thread has reported a pause to the client and is awaiting further instructions. In this state, a thread can accept requests and send replies. If the client asks the thread to continue or step, it returns to the <b>Running</b> state. If the client detaches from the thread, it returns to the <b>Detached</b> state.

* <b>Exited</b>: the thread has ceased execution, and will disappear. The resources of the underlying thread may have been freed; this state merely indicates that the actor's name is not yet available for reuse. When the actor receives a "release" packet, the name may be reused.

[[File:thread-states.png]]

These interactions are meant to have certain properties:

* At no point may either client or server send an unbounded number of packets without receiving a packet from its counterpart. This avoids deadlock without requiring either side to buffer an arbitrary number of packets per actor.

* In states where a transition can be initiated by either the debugger or the thread, it is always clear to the debugger which state the thread actually entered, and for what reason.<p>For example, if the debugger interrupts a running thread, it cannot be sure whether the thread stopped because of the interruption, paused of its own accord (to report a watchpoint hit, say), or exited. However, the next packet the debugger receives will either be "paused", or "exited", resolving the ambiguity.</p><p>Similarly, when the debugger attaches to a thread, it cannot be sure whether it has succeeded in attaching to the thread, or whether the thread exited before the "attach" packet arrived. However, in either case the debugger can expect a disambiguating response: if the attach suceeded, it receives an "attached" packet; and in the second case, it receives an "exit" packet.</p><p>To support this property, the thread ignores certain debugger packets in some states (the "interrupt" packet in the <b>Paused</b> and <b>Exited</b> states, for example). These cases all handle situations where the ignored packet was preempted by some thread action.</p>

Note that the rules here apply to the client's interactions with each thread actor separately. A client may send an "interrupt" to one thread actor while awaiting a reply to a request sent to a different thread actor.

<i>TODO: What about user selecting nodes in displayed content? Should those be eventy things the client can receive in the "paused" state? What does that mean for the "request"/"reply" pattern?</i>

== Attaching To a Thread ==

To attach to a thread, the client sends a packet of the form:

  { "to":<i>thread</i>, "type":"attach" }

Here, <i>thread</i> is the actor representing the thread, perhaps a browsing context from a "listContexts" reply. This packet causes the thread to pause its execution, if it does not exit of its own accord first. The thread responds in one of two ways:

  { "from":<i>thread</i>, "type":"paused", "why":{ "type":"attached" }, ... }

The thread is now in the <b>Paused</b> state, because the client has attached to it. The actor name <i>thread</i> remains valid until the client detaches from the thread or acknowledges a thread exit. This is an ordinary <code>"paused"</code> packet, whose form and additional properties are as described in [[#Thread_Pauses|Thread Pauses]], below.

  { "from":<i>thread</i>, "type":"exited" }

This indicates that the thread exited on its own before receiving the "attach" packet. The thread is now in the <b>Exited</b> state. The client should follow by sending a "release" packet; see [[#Exiting_Threads|Exiting Threads]], below.

If the client sends an <code>"attach"</code> packet to a thread that is not in the <b>Detached</b> or <b>Exited</b> state, the actor sends an error reply of the form:

  { "from":<i>thread</i>, "error":"wrongState", "message":<i>message</i> }

where <i>message</i> details which state the thread was in instead (to make debugging debuggers easier). In this case, the thread's state is unaffected.

== Detaching From a Thread ==

To detach from a thread, the client sends a packet of the form:

  { "to":<i>thread</i>, "type":"detach" }

The thread responds in one of three ways:

  { "from":<i>thread</i>, "type":"detached" }

This indicates that the client has detached from the thread. The thread is now in the <b>Detached</b> state: it can run freely, and no longer reports events to the client. Communications with <i>thread</i> are closed, and the actor name is available for reuse. If the thread had been in the <b>Paused</b> state, the pause actor is closed (because the pause actor is a child of <i>thread</i>).

  { "from":<i>thread</i>, "type":"paused", ... }
  { "from":<i>thread</i>, "type":"detached" }

This series of packets indicates that the thread paused of its own accord (for the reason given by the additional properties of the "paused" packet), and only then received the "detach" packet. As above, this indicates that the thread is in the <b>Detached</b> state, the just-created pause actor is closed, and the actor name is available for reuse.

  { "from":<i>thread</i>, "type":"exited" }

This indicates that the thread exited on its own before receiving the "detach" packet. The client should follow by sending a "release" packet; see [[#Exiting_Threads|Exiting Threads]], below.

Detaching from a thread causes all breakpoints, watchpoints, and other debugging-related state to be forgotten.

If the client sends a <code>"detach"</code> packet to a thread that is not in the <b>Running</b>, <b>Paused</b>, or <b>Exited</b> state, the actor sends an error reply of the form:

  { "from":<i>thread</i>, "error":"wrongState", "message":<i>message</i> }

where <i>message</i> details which state the thread was in instead (to make debugging debuggers easier). In this case, the thread's state is unaffected.

== Running Threads ==

Once the client has attached to a thread, it is in the <b>Running</b> state. In this state, four things can happen:

* The thread can hit a breakpoint or watchpoint, or encounter some other condition of interest to the client.
* The thread can exit.
* The client can detach from the thread.
* The client can interrupt the running thread.

Note that a client action can occur simultaneously with a thread action. The protocol is designed to avoid ambiguities when both client and thread act simultaneously.

== Thread Pauses ==

If the thread pauses to report an interesting event to the client, it sends a packet of the form:

  { "from":<i>thread</i>, "type":"paused", "actor":<i>pauseActor</i>, "why":<i>reason</i>,
    "currentFrame":<i>frame</i>, "poppedFrames":[<i>poppedFrame</i>...] }

This indicates that the thread has entered the <b>Paused</b> state, and explains where and why.

<i>PauseActor</i> is a "pause actor", representing this specific pause of the thread; it lives until the thread next leaves the <b>Paused</b> state. The pause actor parents actors referring to values and other entities uncovered during this pause; when the thread resumes, those actors are automatically closed. This relieves the client from the responsibility to explicitly close every actor mentioned during the pause.

Since actors in value grips are parented by the pause actor, this means that those grips become invalid when the thread resumes, or is detached from; it is not possible to take a grip from one pause and use it in the next. To create a grip that remains valid between pauses, see [[#Grip_Lifetimes|Grip Lifetimes]].

The <i>currentFrame</i> value describes the top frame on the JavaScript stack; see [[#Listing_Stack_Frames|Listing Stack Frames]], below.

The <code>"poppedFrames"</code> property is an array of frame actor names, listing the actors for all frames that were live as of the last pause, but have since been popped. If no frames have been popped, or if this is the first pause for this thread, then this property's value is the empty array.

The <i>reason</i> value describes why the thread paused. It has one of the following forms:

  { "type":"attached" }

The thread paused because the client attached to it.

  { "type":"interrupted" }

The thread stopped because it received an "interrupt" packet from the client.

  { "type":"resumeLimit" }

The client resumed the thread with a <tt>"resume"</tt> packet that included a <tt>resumeLimit</tt> property, and the thread paused because the given <i>limit</i> was met. Execution remains in the frame the thread was resumed in, and that frame is not about to be popped.

  { "type":"resumeLimit", "frameFinished":<i>completion</i> }

The client resumed the thread with a <tt>"resume"</tt> packet that included a <tt>resumeLimit</tt> property, and the thread paused because the frame is about to be popped. <i>Completion</i> is a [[#Completion_Values|completion value]] describing how the frame's execution ended. The frame being popped is still the top frame on the stack, but subsequent <code>"resume"</code> operations will run in the calling frame.

  { "type":"debuggerStatement" }

The thread stopped because it executed a JavaScript "debugger" statement.

  { "type":"breakpoint", "actors":[<i>breakpointActor</i>...] }

The thread stopped at the breakpoints represented by the given actors.

  { "type":"watchpoint", "actors":[<i>watchpointActor</i>...] }

The thread stopped at the watchpoints represented by the given actors.

<i>TODO: This should provide more details about the watchpoint in the packet, instead of incurring another round-trip before we can display anything helpful.</i>

  { "type":"clientEvaluated", "frameFinished":<i>completion</i> }

The expression given in the client's prior <tt>clientEvaluate</tt> command has completed execution; <i>completion</i> is a [[#Completion_Values|completion value]] describing how it completed. The frame created for the <tt>clientEvaluate</tt> resumption has been popped from the stack. See [[#Evaluating_Source-Language_Expressions|Evaluating Source-Language Expressions]] for details.

  { "type":"pauseOnDOMEvents" }

The client resumed the thread with a <tt>"resume"</tt> packet that included a <tt>pauseOnDOMEvents</tt> property, and the thread stopped because it executed an event in that list.

== Resuming a Thread ==

If a thread is in the <b>Paused</b> state, the client can resume it by sending a packet of the following form:

  { "to":<i>thread</i>, "type":"resume" }

This puts the thread in the <b>Running</b> state. The thread will pause again for breakpoint hits, watchpoint hits, throw watches, frame pop watches, and other standing pause requests.

To step a thread's execution, the client can send a packet of the form:

  { "to":<i>thread</i>, "type":"resume", "resumeLimit":<i>limit</i> }

<i>Limit</i> must have one of the following forms:

  { "type":"next" }

The thread should pause:
<ul>
<li>just before the current frame is popped, whether by throwing an exception or returning a value; or
<li>when control in the current frame reaches a different statement than the one it is currently at.
</ul>
Note that execution in frames younger than the current frame never meets these conditions, so a <tt>"next"</tt> limit steps over calls, generator-iterator invocations, and so on.

  { "type":"step" }

The thread should pause:
<ul>
<li>just before the current frame is popped, whether by throwing an exception or returning a value; or
<li>just after a new frame is pushed; or
<li>when control in the current frame reaches a different statement than the one it is currently
at.
</ul>
This is the same as <tt>"next"</tt>, except that it steps into calls.

To resume the thread but have it stop when the current frame is about to be popped, the client can send a packet of the form:

  { "to":<i>thread</i>, "type":"resume", "resumeLimit":{ "type":"finish" } }

Here, the thread should pause just before the current frame is popped, whether by throwing an exception, returning a value, or being terminated.

When a thread pauses because a limit was reached, the "paused" packet's <i>reason</i> will have a type of <tt>"resumeLimit"</tt>.

A resume limit applies only to the current resumption; once the thread pauses, whether because the limit was reached or some other event occurred&mdash;a breakpoint hit, for example&mdash;the resume limit is no longer in effect.

If no <tt>"resumeLimit"</tt> property appears in the <tt>"resume"</tt> packet, then the thread should run until some standing pause condition is met (a breakpoint is hit; a watchpoint triggers; or the like).

To force the current frame to end execution immediately, the client can send a packet of the form:

  { "to":<i>thread</i>, "type":"resume", "forceCompletion":<i>completion</i> }

where <i>completion</i> is a [[#Completion_Values|completion value]] indicating whether the frame should return a value, throw an exception, or be terminated. Execution resumes in the current frame's caller, in the manner appropriate for <i>completion</i>.

To request that execution pause when an exception is thrown, the client may send a request of the form:

  { "to":<i>thread</i>, "type":"resume", "pauseOnExceptions": true }

If <tt>pauseOnExceptions</tt> has the value <tt>false</tt> or is omitted, execution will continue in the face of thrown exceptions. When a thread pauses because an exception was thrown, the "paused" packet's <i>reason</i> will have the following form:

  { "type":"exception", "exception":<i>exception</li> }

where <i>exception</i> is a grip on the exception object.

To request that execution pause on a DOM event, the client may send a request of the form:

  { "to":<i>thread</i>, "type":"resume", "pauseOnDOMEvents": [<i>event-type</i>, ... ] }

The <tt>pauseOnDOMEvents</tt> property contains an array of the types of DOM events that should pause execution. Execution pauses immediately after the frame for the call to the listener has been pushed, and before the listener has begun execution.

A request to pause on all kinds of events can be made using the "*" wildcard event type:

  { "to":<i>thread</i>, "type":"resume", "pauseOnDOMEvents": "*" }

A <tt>pauseOnDOMEvents</tt> applies only until the next pause. In order to change the types of events that should pause execution, a new array of event types should be sent to the server. Any events not present in the new list will no longer trigger pauses. Consequently, sending an empty array or simply omitting the <tt>pauseOnDOMEvents</tt> property disables pausing on DOM events.

When a thread pauses because a DOM event was triggered, the "paused" packet's <i>reason</i> will have a type of <tt>"pauseOnDOMEvents"</tt>.

If a <tt>"forceCompletion"</tt> property is present in a <tt>"resume"</tt> packet, along with <tt>"resumeLimit"</tt>, <tt>"pauseOnExceptions"</tt> or <tt>"pauseOnDOMEvents"</tt>, the thread will respond with an error:

  { "from":<i>thread</i>, "error":"badParameterType", "message":<i>message</i> }

A <tt>"resume"</tt> packet closes the pause actor the client provided in the "paused" packet that began the pause.

If the client sends a <code>"resume"</code> packet to a thread that is not in the <b>Paused</b> state, the actor sends an error reply of the form:

  { "from":<i>thread</i>, "error":"wrongState", "message":<i>message</i> }

where <i>message</i> details which state the thread was in instead (to make debugging debuggers easier). In this case, the thread's state is unaffected.

== Interrupting a Thread ==

If a thread is in the <b>Running</b> state, the client can cause it to pause where it is by sending a packet of the following form:

  { "to":<i>thread</i>, "type":"interrupt" }

The thread responds in one of two ways:

  { "from":<i>thread</i>, "type":"paused", "why":<i>reason</i>, ... }

This indicates that the thread stopped, and is now in the <b>Paused</b> state. If <i>reason</i> is <tt>{ "type":"interrupted" }</tt>, then the thread paused due to the client's <tt>interrupt</tt> packet. Otherwise, the thread paused of its own accord before receiving the <tt>interrupt</tt> packet, and will ignore the <tt>interrupt</tt> packet when it receives it. In either case, this is an ordinary <code>"paused"</code> packet, whose form and additional properties are as described in [[#Thread_Pauses|Thread Pauses]], above.

  { "from":<i>thread</i>, "type":"exited" }

This indicates that the thread exited before receiving the client's <tt>interrupt</tt> packet, and is now in the <b>Exited</b> state. See [[#Exiting_Threads|Exiting Threads]], below.

If the client sends an <code>"interrupt"</code> packet to a thread that is not in the <b>Running</b>, <b>Paused</b>, or <b>Exited</b> state, the actor sends an error reply of the form:

  { "from":<i>thread</i>, "error":"wrongState", "message":<i>message</i> }

where <i>message</i> details which state the thread was in instead (to make debugging debuggers easier). In this case, the thread's state is unaffected.

== Exiting Threads ==

When a thread in the <b>Running</b> state exits, it sends a packet of the following form:

  { "from":<i>thread</i>, "type":"exited" }

At this point, the thread can no longer be manipulated by the client, and most of the thread's resources may be freed; however, the thread actor name must remain alive, to handle stray <tt>interrupt</tt> and <tt>detach</tt> packets. To allow the last trace of the thread to be freed, the client should send a packet of the following form:

  { "to":<i>thread</i>, "type":"release" }

This acknowledges the exit and allows the thread actor name, <i>thread</i>, to be reused for other actors.

= Inspecting Paused Threads =

When a thread is in the <b>Paused</b> state, the debugger can make requests to inspect its stack, lexical environment, and values.

Only those packets explicitly defined to do so can cause the thread to resume execution. JavaScript features like getters, setters, and proxies, which could normally lead inspection operations like enumerating properties and examining their values to run arbitrary JavaScript code, are disabled while the thread is paused. If a given protocol request is not defined to let the thread run, but carrying out the requested operation would normally cause it to do so&mdash;say, fetching the value of a getter property&mdash;the actor sends an error reply of the form:

  { "from":<i>actor</i>, "error":"threadWouldRun", "message":<i>message</i>, "cause":<i>cause</i> }

where <i>message</i> is text that could be displayed to users explaining why the operation could not be carried out. <i>Cause</i> is one of the following strings:

{| frame="box" rules="all" cellpadding="8"
! <i>cause</i> value
! meaning
|-
| "proxy"
| Carrying out the operation would cause a proxy handler to run.
|-
| "getter"
| Carrying out the operation would cause an object property getter to run.
|-
| "setter"
| Carrying out the operation would cause an object property setter to run.
|}

(Taken together, the <tt>"threadWouldRun"</tt> error name and the <i>cause</i> value should allow the debugger to present an appropriately localized error message.)

== Loading Script Sources ==

To get a snapshot of all sources currently loaded by the thread actor, the client can send the following packet:

  { to: <i>threadActorID</i>, type: "sources" }

The response packet has the form:

  { from: <i>threadActorID</i>, sources: [<i>sourceForm1</i>, <i>sourceForm2</i>, ..., <i>sourceFormN</i>] }

Where each <i>sourceForm</i> has the following form:

  { actor: <i>sourceActorID</i>,
    url: <i>sourceURL</i>,
    isBlackBoxed: <i>isBlackBoxed</i> }

* <i>sourceActorID</i> is the source actor's id
* <i>sourceURL</i> is the URL of the source represented by the source actor
* <i>isBlackBoxed</i> is a boolean specifying whether the source actor's 'black-boxed' flag is set. See [[#Black_Boxing_Sources|Black Boxing Sources]].

Each source actor exists throughout the thread's whole lifetime.

To get the contents of a source, send the corresponding source actor the following packet:

  { to: <i>sourceActorID</i>, type: "source" }

And the source actor replies with a packet of the following form:

  { from: <i>sourceActorID</i>, source: <i>contentsOfSource</i> }

where <i>contentsOfSource</i> is a grip representing the string of source code: either a JSON string, or a long string grip. (See [[#Grips|Grips]] for a description of long string grips.)

=== Black-Boxing Sources ===

When debugging a web application that uses large off-the-shelf JavaScript libraries, it may help the developer focus on their own code to treat such libraries as "black boxes", whose internal details are omitted or simplified in the user interface. For example, the user interface could display a sub-chain of stack frames within a black-boxed library as a single element; breakpoints set in a black-boxed library could be disabled; and so on.

Each source actor has a 'black-boxed' flag, and understands requests to set and clear the flag. When a source actor is black-boxed, the debugger does not pause when it hits breakpoints or <code>debugger</code> statements inside that source. If pausing on exceptions is enabled and an exception is thrown inside a black-boxed source, the debugger does not pause until the stack has unwound to a frame in a source that is not black-boxed.

Thread actors still list black-boxed source actors in <code>"sources"</code> replies; and include stack frames running black-boxed code in <code>"frames"</code> requests. However, each <i>sourceForm</i> includes an <code>"isBlackBoxed"</code> property, giving the client all the information it needs to implement the black-boxing behavior in the user interface.

To set a source actor's 'black-boxed' flag:

  { "to": <i>sourceActor</i>, "type": "blackbox" }

The <i>sourceActor</i> responds with a blank response on success:

  { "from": <i>sourceActor</i> }

Or an error response on failure:

  { "from": <i>sourceActor</i>, "error": <i>reason</i> }

To clear a source actor's 'black-boxed' flag:

  { "to": <i>sourceActor</i>, "type": "unblackbox" }

And once again, the <i>sourceActor</i> responds with a blank response on success:

  { "from": <i>sourceActor</i> }

Or an error response on failure:

  { "from": <i>sourceActor</i>, "error": <i>reason</i> }

== Listing Stack Frames ==

To inspect the thread's JavaScript stack, the client can send the following request:

  { "to":<i>thread</i>, "type":"frames", "start":<i>start</i>, "count":<i>count</i> }

The <tt>start</tt> and <tt>count</tt> properties are optional. If present, <i>start</i> gives the number of the youngest stack frame the reply should describe, where the youngest frame on the stack is frame number zero; if absent, <i>start</i> is taken to be zero. If present, <i>count</i> specifies the maximum number of frames the reply should describe; if absent, it is taken to be infinity. (Clients should probably avoid sending <tt>frames</tt> requests with no <i>count</i>, to avoid being flooded by frames from unbounded recursion.)

The thread replies as follows:

  { "from":<i>thread</i>, "frames":[<i>frame</i> ...] }

where each <i>frame</i> has the form:

  { "actor": <i>actor</i>,
    "depth": <i>depth</i>,
    "type": <i>type</i>,
    "this": <i>this</i>,
    ... }

where:

* <i>actor</i> is the name of an actor representing this frame;
* <i>depth</i> is the number of this frame, starting with zero for the youngest frame on the stack;
* <i>type</i> is a string indicating what sort of frame this is; and
* <i>this</i> is a grip on the value of <tt>this</tt> for this call.

The frame may have other properties, depending on <i>type</i>.

All actors mentioned in the frame or grips appearing in the frame (<i>actor</i>, <i>callee</i>, <i>environment</i>, and so on) are parented by the thread actor.

=== Global Code Frames ===

A frame for global code has the form:

  { "actor":<i>actor</i>,
    "depth":<i>depth</i>,
    "type":"global",
    "this":<i>this</i>,
    "where":<i>location</i>,
    "source":<i>source</i>,
    "environment":<i>environment</i> }

where:

* <i>location</i> is the source location of the current point of execution in the global code (see [[#Source_Locations|Source Locations]]);
* <i>environment</i> is a value representing the lexical environment of the current point of execution (see [[#Lexical_Environments|Lexical Environments]]);
* <i>source</i> is a source form as described in [[#Loading_Script_Sources|Loading Script Sources]]

and other properties are as above.

=== Function Call Frames ===

A frame for an ordinary JavaScript function call has the form:

  { "actor":<i>actor</i>, "depth":<i>depth</i>, "type":"call", "this":<i>this</i>,
    "where":<i>location</i>, "environment":<i>environment</i>,
    "callee":<i>callee</i>, "arguments":<i>arguments</i> }

where:

* <i>callee</i> is a grip on the function value being called;
* <i>arguments</i> is an array of grips on the actual values passed to the function;

and other properties are as above.

If the callee is a host function, or a function scoped to some global other than the one to which we are attached, the <tt>"where"</tt> and <tt>"environment"</tt> properties are absent.

The argument list may be incomplete or inaccurate, for various reasons. If the program has assigned to its formal parameters, the original values passed may have been lost, and compiler optimizations may drop some argument values.

=== Eval Frames ===

A frame for a call to <tt>eval</tt> has the form:

  { "actor":<i>actor</i>, "depth":<i>depth</i>, "type":"eval", "this":<i>this</i>,
    "where":<i>location</i>, "environment":<i>environment</i> }

where the properties are as defined above.

=== Client Evaluation Frames ===

When the client evaluates an expression with an <tt>clientEvaluate</tt> packet, the evaluation appears on the stack as a special kind of frame, of the form:

  { "actor":<i>actor</i>, "depth":<i>depth</i>, "type":"clientEvaluate", "this":<i>this</i>,
    "where":<i>location</i>, "environment":<i>environment</i> }

where the properties are as defined above. In this case, <i>where</i> will be a location inside the expression provided by the debugger.

== Popping Stack Frames ==

The client can remove frames from the stack by sending a request of the form:

  { "to":<i>frameActor</i>, "type":"pop", "completionValue":<i>completion</i> }

where <i>frameActor</i> is the actor representing the stack frame to pop, and <i>completion</i> is a [[#Completion_Values|completion value]] describing how the frame should appear to have finished execution. All younger stack frames are also popped. The thread remains paused. The frame actor will reply:

  { "from":<i>frameActor</i>, "watches":[<i>watchActor</i> ...] }

where each <i>watchActor</i> is the name of a frame pop watch actor that has been triggered in the process of popping the given frame. If no frame pop watches are triggered, the <tt>watches</tt> property may be omitted.

<i>TODO: specify the error to return if the frame cannot be popped --- can host (C++) function frames be popped?</i>

== Evaluating Source-Language Expressions ==

To evaluate a source-language expression in a thread, the client sends a specialized <tt>"resume"</tt> packet of the form:

  { "to":<i>thread</i>, "type":"clientEvaluate", "expression":<i>expr</i>, "frame":<i>frame</i> }

This resumes the thread just as an ordinary <tt>"resume"</tt> packet does, but, rather than continuing execution where the pause took place, has the thread begin evaluation of the source-language expression given by <i>expr</i>, a string. The evaluation takes place in a new [[#Client_Evaluation_Frames|Client Evaluation Frame]], pushed on top of <i>thread</i>'s current stack, using the environment of <i>frame</i>. <i>Frame</i> must be a live actor for one of <i>thread</i>'s frames, and the given frame must be one from which we can retrieve a lexical environment; that is, it must not be the frame for a call to a non-debuggee function. When evaluation of <i>expr</i> completes, the client will report a <tt>clientEvaluate</tt> pause containing the expression's value.

If evaluating <i>expr</i> completes abruptly, this outcome is still reported via an <tt>clientEvaluated</tt> pause, so it is not necessary for the client to take explicit steps to catch exceptions thrown by the expression.

If <i>frame</i> is not the name of an actor for a frame currently on <i>thread</i>'s stack, the thread actor sends a reply of the form:

 { "from":<i>thread</i>, "error":"unknownFrame", "message":<i>message</i> }

where <i>message</i> provides any details that would be helpful to the debugger developers. In this case, the thread's state is unaffected.

If <i>frame</i> is not a frame whose environment we can access, the thread actor sends an error reply of the form:

  { "from":<i>thread</i>, "error":"notDebuggee", "message":<i>message</i> }

where <i>message</i> provides further appropriate details.

If the client sends a <code>"clientEvaluate"</code> packet to a thread that is not in the <b>Paused</b> state, the actor sends an error reply of the form:

  { "from":<i>thread</i>, "error":"wrongState", "message":<i>message</i> }

where <i>message</i> details which state the thread was in instead (to make debugging debuggers easier). In this case, the thread's state is unaffected.

<i>TODO: evaluate with given grips bound to given identifiers</i>

= Lexical Environments =

A lexical environment (written as <i>environment</i> in packet descriptions) records the identifier bindings visible at a particular point in the program. An environment has one of the following forms:

  { "type":"object", "actor":<i>actor</i>, "object":<i>object</i>, "parent":<i>parentEnvironment</i> }

This represents a scope chain element whose identifier bindings reflect the properties of <i>object</i> (a grip). This could be the global object (<tt>window</tt> in a browser), or a DOM element (for event handler content attributes, which have the input element, form, and document on their scope chain along with the <tt>window</tt>).

<i>Actor</i> is the name of an actor representing this lexical environment. The requests it can answer are described below.

<i>ParentEnvironment</i> is a lexical environment describing the next enclosing environment; the <tt>parent</tt> property is omitted on the outermost environment.

  { "type":"function", "actor":<i>actor</i>, "function":<i>function</i>,
    "bindings":<i>bindings</i>, "parent":<i>parentEnvironment</i> }

This represents the variable environment created by a call to <i>function</i> (a grip). <i>Bindings</i> describes the bindings in scope, including the function's arguments, the <tt>arguments</tt> object, and local <tt>var</tt> and function bindings; its form is described in detail below. The other properties are as described above.

  { "type":"with", "actor":<i>actor</i>, "object":<i>object</i>, "parent":<i>parentEnvironment</i> }

This represents an environment introduced by a <tt>with</tt> statement whose operand is <i>object</i> (a grip). The other properties are as described above.

  { "type":"block", "actor":<i>actor</i>, "bindings":<i>bindings</i>, "parent":<i>parentEnvironment</i> }

This represents an environment introduced by a <tt>let</tt> block, <tt>for-in</tt> statement, <tt>catch</tt> block, or the like. The properties are as described above.

A <i>bindings</i> value has the form:

  { "arguments":[ { <i>name</i>:<i>descriptor</i> }, ... ],
    "variables":{ <i>name</i>:<i>descriptor</i>, ... } }

Each <i>name</i> is the name of a bound identifier, as a string. Each <i>descriptor</i> is a [[#Property_Descriptors|property descriptor]] for the variable, presenting the variable's value as the descriptor's <tt>"value"</tt> property, and the variable's mutability as the descriptor's <tt>"writable"</tt> property. The descriptor's <tt>"configurable"</tt> property reflects whether the environment supports deleting and adding variables. Each descriptor's <tt>"enumerable"</tt> property is <tt>true</tt>.

The <tt>"arguments"</tt> list appears only in bindings for <tt>"function"</tt> environments. It lists the arguments in the order they appear in the function's definition. (The same name may appear several times in the list, as permitted by JavaScript; the name's last appearance is the one in scope in the function.)

Note that language implementations may omit some environment records from a function's scope if it can determine that the function would not use them. This means that it may be impossible for a debugger to find all the variables that ought to be in scope.

To fully enumerate the bindings introduced by any lexical environment, the client can send a request of the following form to the environment's actor:

  { "to":<i>envActor</i>, "type":"bindings" }

The actor will reply as follows:

  { "from":<i>envActor</i>, "bindings":<i>bindings</i> }

Note that this request elicits a <code>"threadWouldRun"</code> error reply when <i>envActor</i> refers to an object environment whose object is a proxy.

To change the value of a variable bound in a particular lexical environment, the client can send a request to the environment's actor:

  { "to":<i>envActor</i>, "type":"assign", "name":<i>name</i>, "value":<i>value</i> }

This changes the value of the identifier whose name is <i>name</i> (a string) to that represented by <i>value</i> (a grip). The actor will reply as follows, simply:

  { "from":<i>envActor</i> }

If the named identifier is immutable, the actor will send an error reply of the form:

  { "from":<i>envActor</i>, "error":"immutableBinding", "message":<i>message</i> }

If <i>envActor</i> refers to an object environment whose object is a proxy, or whose property named <i>name</i> has a setter function, this request elicits a <code>"threadWouldRun"</code> error reply.

== Lexical Environment Examples ==

For example, if we have the following JavaScript code:

  function f(x) {
    function g(y) {
      var z = "value of z";
      alert(x + y);
    }
  }

we set a breakpoint on the line containing the call to <tt>alert</tt>, and then evaluate the expression:

  f("argument to f")("argument to g")

then we would hit that breakpoint, eliciting a packet like the following:

  { "from":<i>thread</i>, "type":"paused", "actor":<i>pauseActor</i>,
    "why":{ "type":"breakpoint", "actors":[<i>breakpointActor</i>] },
    "frame":{ "actor":<i>frameActor</i>, "depth":1,
              "type":"call", "where":{ "url":"sample.js", "line":3 },
              "environment":{ "type":"function", "actor":<i>gFrameActor</i>,
                              "function":{ "type":"object", "class":"Function", "actor":<i>gActor</i> },
                              "functionName":"g",
                              "bindings":{ arguments: [ { "y": { "value":"argument to g", "configurable":"false",
                                                                 "writable":true, "enumerable":true } } ] },
                              "parent":{ "type":"function", "actor":<i>fFrameActor</i>,
                                         "function":{ "type":"object", "class":"Function", "actor":<i>fActor</i> },
                                         "functionName":"f",
                                         "bindings": { arguments: [ { "x": { "value":"argument to f", "configurable":"false",
                                                                      "writable":true, "enumerable":true } } ],
                                                       variables: { "z": { "value":"value of z", "configurable":"false",
                                                                           "writable":true, "enumerable":true } } },
                                         "parent":{ "type":"object", "actor":<i>globalCodeActor</i>,
                                                    "object":{ "type":"object", "class":"Global",
                                                               "actor":<i>globalObjectActor</i> }
                                                  }
                                       }
                            },
                         "callee":<i>gActor</i>, "calleeName":"g",
              "this":{ "type":"object", "class":"Function", "actor":<i>gActor</i> },
              "arguments":["argument to g"]
            }
  }

You can see here the three nested environment forms, starting with the <tt>environment</tt> property of the top stack frame, reported in the pause:

* The first environment form shows the environment record created by the call to <tt>g</tt>, with the string <tt>"argument to g"</tt> passed as the value of <tt>y</tt>.
* Because <tt>g</tt> is nested within <tt>f</tt>, each function object generated for <tt>g</tt> captures the environment of a call to the enclosing function <tt>f</tt>.  Thus, the next thing on <tt>g</tt>'s scope chain is an environment form for the call to <tt>f</tt>, where <tt>"argument to f"</tt> was passed as the vale of <tt>x</tt>.
* Because <tt>f</tt> is a top-level function, the (only) function object for <tt>f</tt> closes over the global object. This is the "type":"object" environment shown as the parent of <tt>f</tt>'s environment record.
* Because the global object is at the end of the scope chain, its environment form has no <tt>parent</tt> property.

= Breakpoints =

While a thread is paused, a client can set breakpoints in the thread's code by sending requests of the form:

  { "to":<i>thread</i>, "type":"setBreakpoint", "location":<i>location</i> }

where <i>location</i> is a [[#Source_Locations|source location]]. If the thread is able to establish a breakpoint at the given location, it replies:

  { "from":<i>thread</i>, "actor":<i>actor</i>, "actualLocation":<i>actualLocation</i> }

where <i>actor</i> is an actor representing the breakpoint (a child of the thread actor), and <i>actualLocation</i> is the location at which the breakpoint was really set. If <i>location</i> and <i>actualLocation</i> are the same, then the <tt>actualLocation</tt> property can be omitted.

If the thread cannot find the script referred to in <i>location</i>, it sends an error reply of the form:

  { "from":<i>thread</i>, "error":"noScript" }

If <i>location</i> refers to a line and column at which the given script has no program code, and no reasonable alternative location can be chosen (say, by skipping forward), then the thread sends an error reply of the form:

  { "from":<i>thread</i>, "error":"noCodeAtLineColumn" }

To delete a breakpoint, the client can send the breakpoint's actor a message of the form:

  { "to":<i>breakpointActor</i>, "type":"delete" }

to which the breakpoint actor will reply, simply:

  { "from":<i>breakpointActor</i> }

This closes communications with <i>breakpointActor</i>.

= Event Listeners =

To request a list of all the event listeners and event handlers (see [https://developer.mozilla.org/docs/Web/Guide/DOM/Events/Event_handlers#Definitions DOM Event Handlers] for definitions of the two terms) attached to the page, the client sends a request of the form:

  { "to":<i>thread</i>, "type":"eventListeners" }

The thread replies with a response of the form:

  { "from":<i>thread</i>, "listeners":[ <i>listener</i>, ... ] }

Such requests can be sent when the thread is either paused or running. A <i>listener</i> value has the form:

  { "node":{ "selector":<i>node-selector</i>, "object":<i>node</i> },
    "type":<i>type</i>,
    "capturing":<i>capturing</i>,
    "allowsUntrusted":<i>allowsUntrusted</i>,
    "inSystemEventGroup":<i>inSystemEventGroup</i>,
    "isEventHandler":<i>isEventHandler</i>,
    "function":<i>function</i> }

The values for these properties are:
<dl>
<dt><i>node-selector</i>
<dd>A unique CSS selector of the DOM element on which the event handler is attached, or <code>"window"</code> if the handler is attached on the window.
<dt><i>node</i>
<dd>A grip on the DOM element on which the event handler is attached.
<dt><i>type</i>
<dd>The type of the DOM event as specified in the DOM specification (see [https://developer.mozilla.org/docs/XPCOM_Interface_Reference/nsIEventListenerInfo#Attributes nsIEventListenerInfo]).
<dt><i>capturing</i>
<dd>A boolean flag indicating whether the event listener is in capture mode (see [https://developer.mozilla.org/docs/XPCOM_Interface_Reference/nsIEventListenerInfo#Attributes nsIEventListenerInfo]).
<dt><i>allowsUntrusted</i>
<dd>A boolean flag that indicates whether the listener allows untrusted events (see [https://developer.mozilla.org/docs/XPCOM_Interface_Reference/nsIEventListenerInfo#Attributes nsIEventListenerInfo]).
<dt><i>inSystemEventGroup</i>
<dd>A boolean flag that indicates whether or not the event listener is in the system event group (see [https://developer.mozilla.org/docs/XPCOM_Interface_Reference/nsIEventListenerInfo#Attributes nsIEventListenerInfo]).
<dt><i>isEventHandler</i>
<dd>A boolean flag indicating whether this is an event handler or an event listener (see [https://developer.mozilla.org/docs/Web/Guide/DOM/Events/Event_handlers#Definitions DOM Event Handlers] for definitions of the two terms). For HTML attribute handlers or assignments to WebIDL properties this flag would be true.
<dt><i>function</i>
<dd>A grip on the function object.
</dl>

= Watchpoints =
= Frame Pop Watches =

<i>TODO: DOM node inspection, highlighting</i>

<!-- Local Variables: -->
<!-- eval: (visual-line-mode) -->
<!-- page-delimiter: "^=" -->
<!-- End: -->
